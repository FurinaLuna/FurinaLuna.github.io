{"title":"算法设计与分析","slug":"算法设计与分析","date":"2025-11-27T13:17:59.000Z","updated":"2025-11-28T05:05:14.256Z","comments":true,"path":"api/articles/算法设计与分析.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\">前言</h2>\n<blockquote>\n<p><strong>本篇主要用于我自己的复习，如果想速成的话掌握这些够用了，再看看书上或者视频的解题的模板过程</strong></p>\n</blockquote>\n<h2 id=\"考试内容\">考试内容</h2>\n<ul>\n<li>时间复杂度(直接带入和主定理法)</li>\n<li>分治</li>\n<li>动态规划</li>\n<li>贪心算法</li>\n<li>回溯</li>\n<li>分支限界</li>\n</ul>\n<h2 id=\"时间复杂度-直接带入和主定理法\">时间复杂度(直接带入和主定理法)</h2>\n<h2 id=\"分治\">分治</h2>\n<h3 id=\"分治的基本思想\">分治的基本思想</h3>\n<p>将一个较难解决的规模较大的问题，分解成多个相似的规模较小的子问题，递归地解决这些子问题，然后将这些子问题的解合并成原问题的解。</p>\n<h3 id=\"分治的基本步骤\">分治的基本步骤</h3>\n<ol>\n<li>分解：将原问题分解成多个相似的子问题。</li>\n<li>解决：（一般通过递归）地解决这些子问题。</li>\n<li>合并：将这些子问题的解合并成原问题的解。</li>\n</ol>\n<h3 id=\"分治算法的特点（条件）\">分治算法的特点（条件）</h3>\n<ol>\n<li>原问题的规模缩小到一定程度就可以直接解决。</li>\n<li>原问题可以分解成多个相似的子问题。（分治法的前提：最优子结构性质）</li>\n<li>子问题的解可以合并成原问题的解。（能否利用分治法完全取决于这个特征：可以合并）</li>\n<li>子问题之间是独立的，不包含公共的子问题。（子问题相互独立，互不影响）</li>\n</ol>\n<h3 id=\"案例\">案例</h3>\n<ul>\n<li>归并排序</li>\n<li><strong>快速排序</strong></li>\n<li>二分查找</li>\n<li>大整数乘法</li>\n<li>平面内最近点对问题</li>\n<li>矩阵乘法</li>\n<li>Strassen矩阵乘法</li>\n<li>最大子数组问题</li>\n<li>快速傅里叶变换(FFT)</li>\n</ul>\n<h2 id=\"动态规划（带备忘录法自顶向下，空间换时间，储存记录子问题的解，避免重复计算）\">动态规划（带备忘录法自顶向下，空间换时间，储存记录子问题的解，避免重复计算）</h2>\n<h3 id=\"动态规划的基本思想\">动态规划的基本思想</h3>\n<p>解决<strong>多阶段决策最优化问题</strong>的数学模型。将多阶段决策过程分解成多个子问题，每个子问题对应一个阶段，<strong>每个阶段的决策依赖于前一个阶段的决策结果</strong>。通过动态规划的方法，从第一个阶段开始，逐步计算每个阶段的最优解，最终得到多阶段决策过程的最优解。（从全局考虑）</p>\n<h3 id=\"动态规划的基本步骤\">动态规划的基本步骤</h3>\n<ol>\n<li>分析最优解的性质是不是：最优子结构性质、无后效性、重叠子问题，是否满足动规的前提。</li>\n<li>合适划分子问题，子问题重叠度高，考虑动态规划。</li>\n<li>确定动态规划的状态转移方程。</li>\n<li>确定边界条件。</li>\n<li>自底向上计算每个状态的最优解。(迭代)/自顶向下(备忘录法)。</li>\n<li>根据计算结果，构造最优解。用备忘录和标记函数值通过追溯来得到最优解。</li>\n</ol>\n<h3 id=\"特点\">特点</h3>\n<ol>\n<li><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优子结构性质的问题可以用动态规划求解）。</li>\n<li><strong>无后效性（马尔可夫性）</strong>：即某阶段状态一旦确定，则该状态下的决策不再受到以后决策的影响。</li>\n<li><strong>子问题重叠性质</strong>：子问题之间是重叠的，即不同的子问题之间存在公共的子子问题。（与分治法的区别，<strong>分治法的子问题是独立的</strong>，互不影响）</li>\n</ol>\n<h3 id=\"案例-2\">案例</h3>\n<ul>\n<li><strong>0-1背包问题</strong></li>\n<li>最长公共子序列问题</li>\n<li>最大子段和问题（也可以用<strong>分治法</strong>解决）</li>\n<li>矩阵链乘法问题</li>\n<li>最小编辑距离问题</li>\n</ul>\n<h3 id=\"0-1背包问题\">0-1背包问题</h3>\n<h2 id=\"贪心算法\">贪心算法</h2>\n<h3 id=\"贪心算法的基本思想\">贪心算法的基本思想</h3>\n<p><strong>部分最优解</strong>构成<strong>全局最优解</strong>。</p>\n<h3 id=\"贪心的性质（贪心不可以解决0-1背包问题，可以解决部分背包问题）\">贪心的性质（<strong>贪心不可以解决0-1背包问题，可以解决部分背包问题</strong>）</h3>\n<ol>\n<li><strong>贪心选择性质</strong>：每一步都做出当前最优的选择，期望通过一系列的最优选择，最终得到全局最优解。（与动态规划的区别：<strong>动态规划的每一步都考虑了所有可能的选择（全局），而贪心算法只考虑当前最优的选择</strong>。或者说动态规划有重叠子问题性质，贪心有贪心选择性质）</li>\n<li><strong>最优子结构性质</strong>：<strong>问题的最优解包含子问题的最优解。</strong></li>\n</ol>\n<h3 id=\"案例-3\">案例</h3>\n<ul>\n<li>活动选择问题</li>\n<li>哈夫曼编码问题</li>\n<li><strong>最小生成树问题（Kruskal算法，Prim算法）</strong></li>\n<li><strong>单源最短路径问题（Dijkstra算法）</strong></li>\n<li>多机调度问题</li>\n<li><strong>糖果均分问题</strong></li>\n<li><strong>装载问题</strong></li>\n<li><strong>背包问题</strong>（<strong>部分背包问题</strong>，不是0-1背包问题）</li>\n<li>旅行商问题</li>\n<li>最优二叉查找树问题</li>\n<li>最小路径覆盖问题</li>\n<li>最小路径权问题</li>\n<li>最小费用流问题</li>\n<li>最大流问题</li>\n</ul>\n<h2 id=\"回溯（通法，深度优先搜索，栈，递归，剪枝，解空间树的画法）\">回溯（通法，深度优先搜索，栈，递归，剪枝，解空间树的画法）</h2>\n<h3 id=\"回溯的基本思想\">回溯的基本思想</h3>\n<p>搜索<strong>解空间树</strong>，找到所有满足约束条件的<strong>所有解</strong>。</p>\n<h3 id=\"回溯的基本步骤\">回溯的基本步骤</h3>\n<ol>\n<li>针对问题，定义问题的解空间。</li>\n<li>确定<strong>解空间树</strong>的搜索策略。</li>\n<li>确定剪枝函数。</li>\n<li>以<strong>深度优先搜索</strong>的方式，搜索解空间树。</li>\n<li>在解空间树上，从根节点出发，沿着一条路径，不断选择子节点，直到找到一个满足约束条件的解，或者到达叶子节点，无法继续选择。</li>\n<li>如果找到一个满足约束条件的解，则记录下来。</li>\n<li>如果到达叶子节点，无法继续选择，则返回上一个节点，重新选择其他节点，继续搜索。</li>\n<li>重复步骤4-6，直到解空间树上所有节点都被搜索过。</li>\n<li>输出所有满足约束条件的解。<br>\nDFS递归<br>\n模板：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">type <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(type x, ... )</span> <span class=\"hljs-comment\">// 可以存在多个变量</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 达成目标，找到答案</span><br>    &#123;<br>        ... <span class=\"hljs-comment\">// 输出答案或判断最优解等等</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 达到搜索边界（即到边界了还没搜到，有时没有此步骤）</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>( ... ) <span class=\"hljs-comment\">// 遍历所有子节点</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 可以转移状态，一般用标志变量判断</span><br>        &#123;<br>            ... <span class=\"hljs-comment\">// 修改标志变量，表明此节点不可转移</span><br>            <span class=\"hljs-built_in\">dfs</span>( ... ) <span class=\"hljs-comment\">// 搜索子节点，经常为x+1</span><br>            ... <span class=\"hljs-comment\">// 还原标志变量，表面此节点可转移(回溯)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"案例-4\">案例</h3>\n<ul>\n<li>全排列问题</li>\n<li><strong>n皇后问题</strong></li>\n<li>0-1背包问题</li>\n<li>图的着色问题</li>\n<li>旅行商问题</li>\n<li>最大团问题</li>\n<li>最小覆盖问题</li>\n<li>最大流问题</li>\n<li>最小费用流问题</li>\n</ul>\n<h3 id=\"解空间树\">解空间树</h3>\n<ul>\n<li>\n<p>1子集树<br>\n给定问题是从n个元素的集合S中找出满足某种条件的所有子集，相应的解空间树称为子集树。如0-1背包问题的解空间树就是子集树。对于01背包，子集树有2^n+1^-1个节点，每个节点对应一个子集。遍历子集树的时间复杂度为O(2^n)。</p>\n</li>\n<li>\n<p>2排列树<br>\n给定问题是从n个元素找出满足某种条件的所有排列，相应的解空间树称为排列树。如n皇后问题、旅行商问题的解空间树就是排列树。旅行商问题的解空间树有n!个节点，每个节点对应一个排列。遍历排列树的时间复杂度为O(n!)。</p>\n</li>\n</ul>\n<h2 id=\"分支限界\">分支限界</h2>\n<h3 id=\"分支限界的基本思想\">分支限界的基本思想</h3>\n<p>把问题的解空间转化为<strong>解空间树</strong>，然后用<strong>广度优先搜索</strong>或者<strong>最小耗费（最大效益）优先策略</strong>的方式，搜索解空间树。（<strong>找到某一个解/最优解</strong>，<strong>回溯找的是所有解</strong>）</p>\n<h3 id=\"分支限界的方式\">分支限界的方式</h3>\n<p>分支限界根据从活结点表中选择下一个扩展结点的方式，可分为<strong>队列式分支限界</strong>和<strong>优先队列式分支限界</strong>。</p>\n<ul>\n<li>\n<p><strong>队列式分支限界（FIFO）</strong></p>\n</li>\n<li>\n<p><strong>优先队列式分支限界/最小耗费优先/最大效益优先</strong><br>\n出队的队首结点，是优先级最高（最有利）的结点，成为当前扩展结点。<br>\n最大（效益）优先队列：大根堆（大顶堆）（最大化问题）<br>\n最小（耗费）优先队列：小根堆（小顶堆）（最小化问题）</p>\n</li>\n</ul>\n<h3 id=\"左用分支函数，右用限界函数\">左用分支函数，右用限界函数</h3>\n<p><strong>分支函数生成子节点，限界函数判断是否剪枝</strong></p>\n<h3 id=\"案例-5\">案例</h3>\n<ul>\n<li>0-1背包问题</li>\n<li>装载问题</li>\n<li>旅行商问题</li>\n<li>最小路径覆盖问题</li>\n<li>最小路径权问题</li>\n<li>最小费用流问题</li>\n<li>最大流问题</li>\n<li>8数码问题</li>\n</ul>\n","more":"<h2 id=\"前言\">前言</h2>\n<blockquote>\n<p><strong>本篇主要用于我自己的复习，如果想速成的话掌握这些够用了，再看看书上或者视频的解题的模板过程</strong></p>\n</blockquote>\n<h2 id=\"考试内容\">考试内容</h2>\n<ul>\n<li>时间复杂度(直接带入和主定理法)</li>\n<li>分治</li>\n<li>动态规划</li>\n<li>贪心算法</li>\n<li>回溯</li>\n<li>分支限界</li>\n</ul>\n<h2 id=\"时间复杂度-直接带入和主定理法\">时间复杂度(直接带入和主定理法)</h2>\n<h2 id=\"分治\">分治</h2>\n<h3 id=\"分治的基本思想\">分治的基本思想</h3>\n<p>将一个较难解决的规模较大的问题，分解成多个相似的规模较小的子问题，递归地解决这些子问题，然后将这些子问题的解合并成原问题的解。</p>\n<h3 id=\"分治的基本步骤\">分治的基本步骤</h3>\n<ol>\n<li>分解：将原问题分解成多个相似的子问题。</li>\n<li>解决：（一般通过递归）地解决这些子问题。</li>\n<li>合并：将这些子问题的解合并成原问题的解。</li>\n</ol>\n<h3 id=\"分治算法的特点（条件）\">分治算法的特点（条件）</h3>\n<ol>\n<li>原问题的规模缩小到一定程度就可以直接解决。</li>\n<li>原问题可以分解成多个相似的子问题。（分治法的前提：最优子结构性质）</li>\n<li>子问题的解可以合并成原问题的解。（能否利用分治法完全取决于这个特征：可以合并）</li>\n<li>子问题之间是独立的，不包含公共的子问题。（子问题相互独立，互不影响）</li>\n</ol>\n<h3 id=\"案例\">案例</h3>\n<ul>\n<li>归并排序</li>\n<li><strong>快速排序</strong></li>\n<li>二分查找</li>\n<li>大整数乘法</li>\n<li>平面内最近点对问题</li>\n<li>矩阵乘法</li>\n<li>Strassen矩阵乘法</li>\n<li>最大子数组问题</li>\n<li>快速傅里叶变换(FFT)</li>\n</ul>\n<h2 id=\"动态规划（带备忘录法自顶向下，空间换时间，储存记录子问题的解，避免重复计算）\">动态规划（带备忘录法自顶向下，空间换时间，储存记录子问题的解，避免重复计算）</h2>\n<h3 id=\"动态规划的基本思想\">动态规划的基本思想</h3>\n<p>解决<strong>多阶段决策最优化问题</strong>的数学模型。将多阶段决策过程分解成多个子问题，每个子问题对应一个阶段，<strong>每个阶段的决策依赖于前一个阶段的决策结果</strong>。通过动态规划的方法，从第一个阶段开始，逐步计算每个阶段的最优解，最终得到多阶段决策过程的最优解。（从全局考虑）</p>\n<h3 id=\"动态规划的基本步骤\">动态规划的基本步骤</h3>\n<ol>\n<li>分析最优解的性质是不是：最优子结构性质、无后效性、重叠子问题，是否满足动规的前提。</li>\n<li>合适划分子问题，子问题重叠度高，考虑动态规划。</li>\n<li>确定动态规划的状态转移方程。</li>\n<li>确定边界条件。</li>\n<li>自底向上计算每个状态的最优解。(迭代)/自顶向下(备忘录法)。</li>\n<li>根据计算结果，构造最优解。用备忘录和标记函数值通过追溯来得到最优解。</li>\n</ol>\n<h3 id=\"特点\">特点</h3>\n<ol>\n<li><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优子结构性质的问题可以用动态规划求解）。</li>\n<li><strong>无后效性（马尔可夫性）</strong>：即某阶段状态一旦确定，则该状态下的决策不再受到以后决策的影响。</li>\n<li><strong>子问题重叠性质</strong>：子问题之间是重叠的，即不同的子问题之间存在公共的子子问题。（与分治法的区别，<strong>分治法的子问题是独立的</strong>，互不影响）</li>\n</ol>\n<h3 id=\"案例-2\">案例</h3>\n<ul>\n<li><strong>0-1背包问题</strong></li>\n<li>最长公共子序列问题</li>\n<li>最大子段和问题（也可以用<strong>分治法</strong>解决）</li>\n<li>矩阵链乘法问题</li>\n<li>最小编辑距离问题</li>\n</ul>\n<h3 id=\"0-1背包问题\">0-1背包问题</h3>\n<h2 id=\"贪心算法\">贪心算法</h2>\n<h3 id=\"贪心算法的基本思想\">贪心算法的基本思想</h3>\n<p><strong>部分最优解</strong>构成<strong>全局最优解</strong>。</p>\n<h3 id=\"贪心的性质（贪心不可以解决0-1背包问题，可以解决部分背包问题）\">贪心的性质（<strong>贪心不可以解决0-1背包问题，可以解决部分背包问题</strong>）</h3>\n<ol>\n<li><strong>贪心选择性质</strong>：每一步都做出当前最优的选择，期望通过一系列的最优选择，最终得到全局最优解。（与动态规划的区别：<strong>动态规划的每一步都考虑了所有可能的选择（全局），而贪心算法只考虑当前最优的选择</strong>。或者说动态规划有重叠子问题性质，贪心有贪心选择性质）</li>\n<li><strong>最优子结构性质</strong>：<strong>问题的最优解包含子问题的最优解。</strong></li>\n</ol>\n<h3 id=\"案例-3\">案例</h3>\n<ul>\n<li>活动选择问题</li>\n<li>哈夫曼编码问题</li>\n<li><strong>最小生成树问题（Kruskal算法，Prim算法）</strong></li>\n<li><strong>单源最短路径问题（Dijkstra算法）</strong></li>\n<li>多机调度问题</li>\n<li><strong>糖果均分问题</strong></li>\n<li><strong>装载问题</strong></li>\n<li><strong>背包问题</strong>（<strong>部分背包问题</strong>，不是0-1背包问题）</li>\n<li>旅行商问题</li>\n<li>最优二叉查找树问题</li>\n<li>最小路径覆盖问题</li>\n<li>最小路径权问题</li>\n<li>最小费用流问题</li>\n<li>最大流问题</li>\n</ul>\n<h2 id=\"回溯（通法，深度优先搜索，栈，递归，剪枝，解空间树的画法）\">回溯（通法，深度优先搜索，栈，递归，剪枝，解空间树的画法）</h2>\n<h3 id=\"回溯的基本思想\">回溯的基本思想</h3>\n<p>搜索<strong>解空间树</strong>，找到所有满足约束条件的<strong>所有解</strong>。</p>\n<h3 id=\"回溯的基本步骤\">回溯的基本步骤</h3>\n<ol>\n<li>针对问题，定义问题的解空间。</li>\n<li>确定<strong>解空间树</strong>的搜索策略。</li>\n<li>确定剪枝函数。</li>\n<li>以<strong>深度优先搜索</strong>的方式，搜索解空间树。</li>\n<li>在解空间树上，从根节点出发，沿着一条路径，不断选择子节点，直到找到一个满足约束条件的解，或者到达叶子节点，无法继续选择。</li>\n<li>如果找到一个满足约束条件的解，则记录下来。</li>\n<li>如果到达叶子节点，无法继续选择，则返回上一个节点，重新选择其他节点，继续搜索。</li>\n<li>重复步骤4-6，直到解空间树上所有节点都被搜索过。</li>\n<li>输出所有满足约束条件的解。<br>\nDFS递归<br>\n模板：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">type <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(type x, ... )</span> <span class=\"hljs-comment\">// 可以存在多个变量</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 达成目标，找到答案</span><br>    &#123;<br>        ... <span class=\"hljs-comment\">// 输出答案或判断最优解等等</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 达到搜索边界（即到边界了还没搜到，有时没有此步骤）</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>( ... ) <span class=\"hljs-comment\">// 遍历所有子节点</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>( ... ) <span class=\"hljs-comment\">// 可以转移状态，一般用标志变量判断</span><br>        &#123;<br>            ... <span class=\"hljs-comment\">// 修改标志变量，表明此节点不可转移</span><br>            <span class=\"hljs-built_in\">dfs</span>( ... ) <span class=\"hljs-comment\">// 搜索子节点，经常为x+1</span><br>            ... <span class=\"hljs-comment\">// 还原标志变量，表面此节点可转移(回溯)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"案例-4\">案例</h3>\n<ul>\n<li>全排列问题</li>\n<li><strong>n皇后问题</strong></li>\n<li>0-1背包问题</li>\n<li>图的着色问题</li>\n<li>旅行商问题</li>\n<li>最大团问题</li>\n<li>最小覆盖问题</li>\n<li>最大流问题</li>\n<li>最小费用流问题</li>\n</ul>\n<h3 id=\"解空间树\">解空间树</h3>\n<ul>\n<li>\n<p>1子集树<br>\n给定问题是从n个元素的集合S中找出满足某种条件的所有子集，相应的解空间树称为子集树。如0-1背包问题的解空间树就是子集树。对于01背包，子集树有2^n+1^-1个节点，每个节点对应一个子集。遍历子集树的时间复杂度为O(2^n)。</p>\n</li>\n<li>\n<p>2排列树<br>\n给定问题是从n个元素找出满足某种条件的所有排列，相应的解空间树称为排列树。如n皇后问题、旅行商问题的解空间树就是排列树。旅行商问题的解空间树有n!个节点，每个节点对应一个排列。遍历排列树的时间复杂度为O(n!)。</p>\n</li>\n</ul>\n<h2 id=\"分支限界\">分支限界</h2>\n<h3 id=\"分支限界的基本思想\">分支限界的基本思想</h3>\n<p>把问题的解空间转化为<strong>解空间树</strong>，然后用<strong>广度优先搜索</strong>或者<strong>最小耗费（最大效益）优先策略</strong>的方式，搜索解空间树。（<strong>找到某一个解/最优解</strong>，<strong>回溯找的是所有解</strong>）</p>\n<h3 id=\"分支限界的方式\">分支限界的方式</h3>\n<p>分支限界根据从活结点表中选择下一个扩展结点的方式，可分为<strong>队列式分支限界</strong>和<strong>优先队列式分支限界</strong>。</p>\n<ul>\n<li>\n<p><strong>队列式分支限界（FIFO）</strong></p>\n</li>\n<li>\n<p><strong>优先队列式分支限界/最小耗费优先/最大效益优先</strong><br>\n出队的队首结点，是优先级最高（最有利）的结点，成为当前扩展结点。<br>\n最大（效益）优先队列：大根堆（大顶堆）（最大化问题）<br>\n最小（耗费）优先队列：小根堆（小顶堆）（最小化问题）</p>\n</li>\n</ul>\n<h3 id=\"左用分支函数，右用限界函数\">左用分支函数，右用限界函数</h3>\n<p><strong>分支函数生成子节点，限界函数判断是否剪枝</strong></p>\n<h3 id=\"案例-5\">案例</h3>\n<ul>\n<li>0-1背包问题</li>\n<li>装载问题</li>\n<li>旅行商问题</li>\n<li>最小路径覆盖问题</li>\n<li>最小路径权问题</li>\n<li>最小费用流问题</li>\n<li>最大流问题</li>\n<li>8数码问题</li>\n</ul>\n","categories":[{"name":"期末复习","path":"api/categories/期末复习.json"}],"tags":[{"name":"期末考试 算法设计与分析 专业课","path":"api/tags/期末考试 算法设计与分析 专业课.json"}]}